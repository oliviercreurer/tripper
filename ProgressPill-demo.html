<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ProgressPill — Component Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #root { height: 100%; width: 100%; }
    body {
      background: #f5f3ee;
      font-family: 'Outfit', sans-serif;
      -webkit-font-smoothing: antialiased;
      color: #1c1b1a;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
  <script type="text/babel" data-type="module">
    const { useState, useEffect, useLayoutEffect, useRef, useCallback } = React;

    // ═══════════════════════════════════════════════════════════════
    // ProgressPill — self-contained component
    // ═══════════════════════════════════════════════════════════════

    const BG     = "#fffdf6";
    const BORDER = "#DAD8CE";
    const SUBTLE = "#6f6e69";

    const TRACK_RGB = [
      [249, 174, 119],
      [236, 203,  96],
      [146, 191, 219],
      [196, 185, 224],
    ];
    const BG_RGB = [
      [255, 231, 206],
      [250, 238, 198],
      [225, 236, 235],
      [240, 234, 236],
    ];

    function lerpColors(palette, t) {
      const boundaries = [0.25, 0.5, 0.75];
      const halfTrans  = 0.035;
      let c = palette[0];
      for (let b = 0; b < boundaries.length; b++) {
        const bd = boundaries[b];
        if (t > bd + halfTrans) {
          c = palette[b + 1];
        } else if (t > bd - halfTrans) {
          const f = (t - (bd - halfTrans)) / (2 * halfTrans);
          const s = f * f * (3 - 2 * f);
          c = palette[b].map((v, k) => Math.round(v + (palette[b + 1][k] - v) * s));
        }
      }
      return c;
    }
    function rgb(c) { return `rgb(${c[0]},${c[1]},${c[2]})`; }

    const PW = 230, PH = 48, SW = 4;
    const INSET = SW / 2, PR = (PH - SW) / 2;
    function pillD() {
      const i = INSET, w = PW - SW, h = PH - SW, r = PR;
      const cx = PW / 2;
      return [
        `M ${cx} ${i}`, `L ${i+w-r} ${i}`,
        `A ${r} ${r} 0 0 1 ${i+w} ${i+r}`, `A ${r} ${r} 0 0 1 ${i+w-r} ${i+h}`,
        `L ${i+r} ${i+h}`, `A ${r} ${r} 0 0 1 ${i} ${i+r}`,
        `A ${r} ${r} 0 0 1 ${i+r} ${i}`, `L ${cx} ${i}`,
      ].join(" ");
    }
    const PILL_D = pillD();

    function ProgressPill({ dayNumber, distance, progress }) {
      const canvasRef  = useRef(null);
      const ctxRef     = useRef(null);
      const pathRef    = useRef(null);
      const pointsRef  = useRef([]);
      const dotRef     = useRef(null);
      const displayRef = useRef(0);
      const targetRef  = useRef(0);
      const rafRef     = useRef(null);
      const [ready, setReady] = useState(false);
      const hasStartedRef = useRef(false);
      if (progress > 0.01) hasStartedRef.current = true;

      const prevDayNumRef = useRef(dayNumber);
      const dayTransitionRef = useRef(null);

      useEffect(() => {
        if (dayNumber !== prevDayNumRef.current) {
          const wentBack = dayNumber < prevDayNumRef.current;
          if (wentBack) {
            displayRef.current = progress;
            targetRef.current = progress;
            dayTransitionRef.current = { fromColor: lerpColors(TRACK_RGB, 0.0), fade: 0 };
          }
          prevDayNumRef.current = dayNumber;
        }
      }, [dayNumber, progress]);

      targetRef.current = progress;

      useEffect(() => {
        const cvs = canvasRef.current;
        const dpr = window.devicePixelRatio || 1;
        cvs.width  = PW * dpr; cvs.height = PH * dpr;
        cvs.style.width = PW + "px"; cvs.style.height = PH + "px";
        const ctx = cvs.getContext("2d");
        ctx.scale(dpr, dpr);
        ctxRef.current = ctx;
        const path = pathRef.current;
        const totalLen = path.getTotalLength();
        const step = 1.4, n = Math.ceil(totalLen / step);
        const pts = [];
        for (let i = 0; i <= n; i++) {
          const t = i / n;
          const pt = path.getPointAtLength(t * totalLen);
          pts.push({ x: pt.x, y: pt.y, t });
        }
        pointsRef.current = pts;
        setReady(true);
      }, []);

      useLayoutEffect(() => {
        const ctx = ctxRef.current, pts = pointsRef.current;
        if (!ctx || pts.length === 0) return;
        ctx.clearRect(0, 0, PW, PH);
        if (progress < 0.003) return;
        ctx.lineWidth = SW; ctx.lineCap = "butt";
        const visibleIdx = Math.floor(Math.min(progress, 0.998) * (pts.length - 1));
        const trans = dayTransitionRef.current;
        let trackColor;
        if (trans && trans.fade < 1) {
          const tc = lerpColors(TRACK_RGB, Math.min(progress, 0.998));
          const f = trans.fade;
          trackColor = rgb([
            Math.round(trans.fromColor[0]*(1-f)+tc[0]*f),
            Math.round(trans.fromColor[1]*(1-f)+tc[1]*f),
            Math.round(trans.fromColor[2]*(1-f)+tc[2]*f),
          ]);
        } else {
          trackColor = rgb(lerpColors(TRACK_RGB, Math.min(progress, 0.998)));
        }
        ctx.strokeStyle = trackColor;
        for (let i = 0; i < visibleIdx; i++) {
          const p1 = pts[i], p2 = pts[i+1];
          if (!p2) break;
          const dx = p2.x-p1.x, dy = p2.y-p1.y;
          const segLen = Math.sqrt(dx*dx+dy*dy);
          const ov = segLen > 0 ? 0.3/segLen : 0;
          ctx.beginPath(); ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x+dx*ov, p2.y+dy*ov); ctx.stroke();
        }
      }, [progress, ready]);

      useEffect(() => {
        if (!ready) return;
        let lastTime = 0;
        const EASE = 12;
        function tick(now) {
          rafRef.current = requestAnimationFrame(tick);
          const dt = lastTime ? Math.min((now-lastTime)/1000, 0.05) : 0.016;
          lastTime = now;
          const trans = dayTransitionRef.current;
          if (trans && trans.fade < 1) {
            trans.fade = Math.min(trans.fade + dt*2.5, 1);
            if (trans.fade >= 1) dayTransitionRef.current = null;
          }
          const target = targetRef.current, current = displayRef.current;
          const diff = target - current;
          if (diff < -0.3) { displayRef.current = target; }
          else {
            const step = 1 - Math.exp(-EASE*dt);
            displayRef.current = current + diff*step;
            if (Math.abs(diff) < 0.001) displayRef.current = target;
          }
          const dot = dotRef.current, pts = pointsRef.current;
          if (!dot || pts.length === 0 || !hasStartedRef.current) return;
          const p = Math.min(Math.max(displayRef.current, 0), 0.998);
          const idx = Math.min(Math.floor(p*(pts.length-1)), pts.length-1);
          const pt = pts[idx];
          dot.setAttribute("cx", pt.x); dot.setAttribute("cy", pt.y);
          if (trans && trans.fade < 1) {
            const f = trans.fade;
            const tBg = lerpColors(BG_RGB, pt.t), tSt = lerpColors(TRACK_RGB, pt.t);
            const fBg = lerpColors(BG_RGB, 0.0), fSt = trans.fromColor;
            dot.setAttribute("fill", rgb([Math.round(fBg[0]*(1-f)+tBg[0]*f), Math.round(fBg[1]*(1-f)+tBg[1]*f), Math.round(fBg[2]*(1-f)+tBg[2]*f)]));
            dot.setAttribute("stroke", rgb([Math.round(fSt[0]*(1-f)+tSt[0]*f), Math.round(fSt[1]*(1-f)+tSt[1]*f), Math.round(fSt[2]*(1-f)+tSt[2]*f)]));
          } else {
            dot.setAttribute("fill", rgb(lerpColors(BG_RGB, pt.t)));
            dot.setAttribute("stroke", rgb(lerpColors(TRACK_RGB, pt.t)));
          }
        }
        rafRef.current = requestAnimationFrame(tick);
        return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); };
      }, [ready]);

      const labelColor = "#100F0F";
      const [textPhase, setTextPhase] = useState("idle");
      const [displayDay, setDisplayDay] = useState(dayNumber);
      const [displayDist, setDisplayDist] = useState(distance);
      const prevDayRef = useRef(dayNumber);

      useEffect(() => {
        if (dayNumber === prevDayRef.current) return;
        prevDayRef.current = dayNumber;
        setTextPhase("exiting");
        const exitTimer = setTimeout(() => {
          setDisplayDay(dayNumber); setDisplayDist(distance);
          setTextPhase("entering");
          const enterTimer = setTimeout(() => { setTextPhase("idle"); }, 280);
          return () => clearTimeout(enterTimer);
        }, 240);
        return () => clearTimeout(exitTimer);
      }, [dayNumber, distance]);

      useEffect(() => {
        if (textPhase === "idle" && dayNumber === displayDay) setDisplayDist(distance);
      }, [distance, textPhase, dayNumber, displayDay]);

      const textStyle = (() => {
        switch (textPhase) {
          case "exiting": return { opacity: 0, transform: "translateY(-10px)", transition: "opacity .24s ease-in, transform .24s ease-in" };
          case "entering": return { opacity: 1, transform: "translateY(0px)", transition: "opacity .28s ease-out, transform .28s ease-out" };
          default: return { opacity: 1, transform: "translateY(0px)", transition: "none" };
        }
      })();

      const textEnterRef = useRef(null);
      useLayoutEffect(() => {
        if (textPhase === "entering" && textEnterRef.current) {
          const el = textEnterRef.current;
          el.style.transition = "none"; el.style.opacity = "0"; el.style.transform = "translateY(10px)";
          el.getBoundingClientRect();
          el.style.transition = "opacity .28s ease-out, transform .28s ease-out";
          el.style.opacity = "1"; el.style.transform = "translateY(0px)";
        }
      }, [textPhase]);

      const initX = PW / 2, initY = INSET;

      return (
        <div style={{ position: "relative", width: PW, height: PH }}>
          <svg width={PW} height={PH} viewBox={`0 0 ${PW} ${PH}`}
               style={{ position: "absolute", top: 0, left: 0, overflow: "visible" }}>
            <rect x={INSET} y={INSET} width={PW-SW} height={PH-SW}
                  rx={PR} ry={PR} fill={BG} stroke={BORDER} strokeWidth={SW} />
            <path ref={pathRef} d={PILL_D} fill="none" stroke="none" />
          </svg>
          <canvas ref={canvasRef} style={{ position: "absolute", top: 0, left: 0, pointerEvents: "none" }} />
          {hasStartedRef.current && (
            <svg width={PW} height={PH} viewBox={`0 0 ${PW} ${PH}`}
                 style={{ position: "absolute", top: 0, left: 0, overflow: "visible", pointerEvents: "none" }}>
              <circle ref={dotRef} cx={initX} cy={initY} r={5.5}
                      fill={rgb(BG_RGB[0])} stroke={rgb(TRACK_RGB[0])} strokeWidth={2.5}
                      style={{ filter: "drop-shadow(0 1px 2px rgba(0,0,0,0.12))" }} />
            </svg>
          )}
          <div style={{
            position: "absolute", inset: 0, overflow: "hidden",
            display: "flex", alignItems: "center", justifyContent: "center", pointerEvents: "none",
          }}>
            <div ref={textEnterRef} style={{
              display: "flex", alignItems: "center", justifyContent: "center", gap: 12, ...textStyle,
            }}>
              <span style={{
                fontFamily: "'Outfit', sans-serif", fontWeight: 600, fontSize: 16,
                color: labelColor, fontFeatureSettings: "'lnum' 1, 'tnum' 1",
              }}>Day {displayDay}</span>
              <svg width="1" height="16" style={{ flexShrink: 0 }}>
                <line x1=".5" y1="0" x2=".5" y2="16" stroke={BORDER} />
              </svg>
              <span style={{
                fontFamily: "'JetBrains Mono', monospace", fontSize: 14, color: SUBTLE,
              }}>{displayDist}</span>
            </div>
          </div>
        </div>
      );
    }

    // ═══════════════════════════════════════════════════════════════
    // Demo App — interactive controls
    // ═══════════════════════════════════════════════════════════════

    const DAYS = [
      { day: 1, distance: "152.7km" },
      { day: 2, distance: "84.3km" },
      { day: 3, distance: "210.1km" },
      { day: 4, distance: "63.8km" },
    ];

    function Demo() {
      const [dayIdx, setDayIdx] = useState(0);
      const [progress, setProgress] = useState(0);
      const [autoplay, setAutoplay] = useState(false);
      const autoRef = useRef(null);

      // Autoplay: fill → next day → fill → loop
      useEffect(() => {
        if (!autoplay) { if (autoRef.current) cancelAnimationFrame(autoRef.current); return; }
        let last = 0;
        function tick(now) {
          autoRef.current = requestAnimationFrame(tick);
          const dt = last ? (now - last) / 1000 : 0;
          last = now;
          setProgress(prev => {
            const next = prev + dt * 0.18; // ~5.5s per day
            if (next >= 1) {
              setDayIdx(di => (di + 1) % DAYS.length);
              return 0;
            }
            return next;
          });
        }
        autoRef.current = requestAnimationFrame(tick);
        return () => { if (autoRef.current) cancelAnimationFrame(autoRef.current); };
      }, [autoplay]);

      const day = DAYS[dayIdx];

      const label = {
        fontFamily: "'Outfit', sans-serif", fontWeight: 500, fontSize: 13,
        color: "#6f6e69", lineHeight: "20px",
      };
      const value = {
        fontFamily: "'JetBrains Mono', monospace", fontSize: 14,
        color: "#1c1b1a", lineHeight: "20px", minWidth: 72,
      };

      return (
        <div style={{
          minHeight: "100vh", display: "flex", flexDirection: "column",
          alignItems: "center", justifyContent: "center", gap: 48,
          padding: "48px 24px",
        }}>
          {/* Title */}
          <div style={{ textAlign: "center", display: "flex", flexDirection: "column", gap: 8 }}>
            <h1 style={{
              fontFamily: "'Outfit', sans-serif", fontWeight: 600, fontSize: 28,
              color: "#1c1b1a", letterSpacing: "-0.3px",
            }}>ProgressPill</h1>
            <p style={{
              fontFamily: "'Outfit', sans-serif", fontWeight: 400, fontSize: 16,
              color: "#6f6e69", maxWidth: 420, lineHeight: "24px",
            }}>
              Scroll-driven day progress indicator with gradient stroke,
              animated dot, and crossfade day transitions.
            </p>
          </div>

          {/* Pill display */}
          <div style={{
            background: "#fffdf6", borderRadius: 20, padding: "48px 64px",
            boxShadow: "0 1px 3px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.04)",
            display: "flex", alignItems: "center", justifyContent: "center",
          }}>
            <ProgressPill dayNumber={day.day} distance={day.distance} progress={progress} />
          </div>

          {/* Controls */}
          <div style={{
            background: "#fffdf6", borderRadius: 16, padding: "28px 32px",
            boxShadow: "0 1px 3px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.04)",
            display: "flex", flexDirection: "column", gap: 20,
            width: "100%", maxWidth: 400,
          }}>
            {/* Progress slider */}
            <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <span style={label}>Progress</span>
                <span style={value}>{(progress * 100).toFixed(1)}%</span>
              </div>
              <input type="range" min="0" max="1" step="0.002"
                value={progress}
                onChange={e => { setAutoplay(false); setProgress(parseFloat(e.target.value)); }}
                style={{ width: "100%", accentColor: "#92BFDB" }}
              />
            </div>

            {/* Day selector */}
            <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
              <span style={label}>Day</span>
              <div style={{ display: "flex", gap: 8 }}>
                {DAYS.map((d, i) => (
                  <button key={d.day}
                    onClick={() => { setAutoplay(false); setDayIdx(i); setProgress(0); }}
                    style={{
                      flex: 1, padding: "8px 0", borderRadius: 10,
                      border: i === dayIdx ? "2px solid #92BFDB" : "1px solid #DAD8CE",
                      background: i === dayIdx ? "#E1ECEB" : "#fffdf6",
                      fontFamily: "'Outfit', sans-serif", fontWeight: 600, fontSize: 14,
                      color: i === dayIdx ? "#1c1b1a" : "#6f6e69",
                      cursor: "pointer", transition: "all .2s ease",
                    }}
                  >
                    Day {d.day}
                  </button>
                ))}
              </div>
            </div>

            {/* Autoplay */}
            <button
              onClick={() => setAutoplay(a => !a)}
              style={{
                padding: "10px 0", borderRadius: 10,
                border: "none",
                background: autoplay ? "#F9AE77" : "#1c1b1a",
                fontFamily: "'Outfit', sans-serif", fontWeight: 600, fontSize: 14,
                color: autoplay ? "#1c1b1a" : "#fffdf6",
                cursor: "pointer", transition: "all .2s ease",
              }}
            >
              {autoplay ? "⏸  Pause" : "▶  Autoplay"}
            </button>
          </div>

          {/* Props table */}
          <div style={{
            background: "#fffdf6", borderRadius: 16, padding: "24px 28px",
            boxShadow: "0 1px 3px rgba(0,0,0,.06), 0 0 0 1px rgba(0,0,0,.04)",
            width: "100%", maxWidth: 400,
            display: "flex", flexDirection: "column", gap: 12,
          }}>
            <span style={{ ...label, fontWeight: 600, fontSize: 14, color: "#1c1b1a" }}>Props</span>
            <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
              {[
                ["dayNumber", "number", "Current day (1-based)"],
                ["distance", "string", 'Display string, e.g. "152.7km"'],
                ["progress", "number", "0 → 1 scroll depth within day"],
              ].map(([name, type, desc]) => (
                <div key={name} style={{ display: "flex", gap: 8, alignItems: "baseline" }}>
                  <code style={{
                    fontFamily: "'JetBrains Mono', monospace", fontSize: 13,
                    color: "#5B94B8", background: "#E1ECEB", borderRadius: 4,
                    padding: "1px 6px", flexShrink: 0,
                  }}>{name}</code>
                  <span style={{ ...label, fontSize: 12, color: "#b7b5ac", flexShrink: 0 }}>{type}</span>
                  <span style={{ ...label, fontSize: 12 }}>{desc}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<Demo />);
  </script>
</body>
</html>
